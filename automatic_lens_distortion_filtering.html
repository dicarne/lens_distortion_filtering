<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Radial lens undistortion filter</title>
  <script type="text/javascript" src="utils/glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>
  <script type="text/javascript" src="utils/raphael-min.js"></script>
  <script type="text/javascript" src="utils/g.raphael-min.js"></script>
  <script type="text/javascript" src="utils/g.bar-min.js"></script>


  <script id="neuter-shader-fs" type="x-shader/x-fragment">
    // A neuter fragment shader, just samples the texture and returns its color
    
    precision highp float;
    uniform sampler2D texture_diffuse;
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    void main(void) {
        gl_FragColor = texture2D(texture_diffuse, pass_TextureCoord);
    }
  </script>
  <script id="neuter-shader-vs" type="x-shader/x-vertex">    
    // A neuter vertex shader, just passes XYZW, RGBA, UV coords to the
    // next fragment shader

    attribute vec4 in_Position;
    attribute vec4 in_Color;
    attribute vec2 in_TextureCoord;    

    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * in_Position;
      
      pass_Color = in_Color;
      pass_TextureCoord = in_TextureCoord;
    }
  </script>

  <!-- Radial distortion filter shaders  -->
  
  <script id="undistortion-shader-fs" type="x-shader/x-fragment">
    // Renders to the target framebuffer an undistorted version of the input
    // texture via an approximate radial undistortion filtering
    precision highp float;
    
    uniform sampler2D texture_diffuse;
    uniform vec2 image_dimensions;
    uniform float alphax;
    uniform float alphay;
    
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    // Deals with floating point imprecisions
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    void main(void) {
    
      // Normalize the u,v coordinates in the range [-1;+1]
      float x = (2.0 * pass_TextureCoord.x - 1.0) / 1.0;
      float y = (2.0 * pass_TextureCoord.y - 1.0) / 1.0;
      
      // Calculate l2 norm
      float r = x * x + y * y;
      
      // Calculate the deflated or inflated new coordinate (reverse transform)
      float x3 = x / (1.0 - alphax * r);
      float y3 = y / (1.0 - alphay * r); 
      float x2 = x / (1.0 - alphax * (x3 * x3 + y3 * y3));
      float y2 = y / (1.0 - alphay * (x3 * x3 + y3 * y3));  
      
      // Forward transform
      // float x2 = x * (1.0 - alphax * r);
      // float y2 = y * (1.0 - alphay * r);

      // De-normalize to the original range
      float i2 = (x2 + 1.0) * 1.0 / 2.0;
      float j2 = (y2 + 1.0) * 1.0 / 2.0;      
    
      if(i2 >= 0.0 && i2 <= 1.0 && j2 >= 0.0 && j2 <= 1.0) // If a valid texture coord
      {
        vec4 texture_color = texture2D(texture_diffuse, vec2(i2, j2));    

        // Important: borders are unreliable in lens correction (they incorrectly ramp up Sobel
        // kernel's response). In order to detect those we set the alpha value to 0
        // on the border of the input image before transferring it to the GPU

        float alpha = 1.0;
        if(isAboutEqual(i2, 0.0) || isAboutEqual(j2, 0.0) ||
           isAboutEqual(i2, 1.0) || isAboutEqual(j2, 1.0))
          alpha = 0.0;
            
        texture_color.a = alpha;

        gl_FragColor = texture_color; // Finally store the result
      } else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); // alpha is set to zero, i.e. don't compute
    }
  </script>
  
  <!-- Histogram computer shader -->
  <script id="histogram-computer-shader-fs" type="x-shader/x-fragment">
    // Computes an edge-response histogram in a texture
    precision highp float;
    
    uniform sampler2D input_texture;
    uniform vec2 input_texture_size;    

    //
    // Rotation vectors for the kernel. We're interested into covering a 360째
    // region for a pixel by rotating the sobel kernel multiple times. Since
    // we only care for edge directions and not orientation we'll sweep 180째
    // by using 3 degrees increments, i.e. 180/3 = 12*5 increments. To speed the
    // computation we precompute these vectors (as a couple of (x;y) vector
    // components) on the CPU and then pass it to the shader here.
    //
    // There are two steps:
    // 1) Test each pixel against one of the 12*5 3째 increments and detect the
    //    maximum response
    // 2) Each "reactive" bin is further refined with an anti-aliasing response boost
    //
    uniform vec2 rotation_du[12 * 5];
    uniform float response_boost[12 * 5];
    
    varying vec4 pass_Color; // Unused/for debugging purposes
    varying vec2 pass_TextureCoord;

    float applyThreshold(float value, float threshold) {
      if(value < threshold)
        value = 0.0;
      return value;
    }

    // Check if a point (range [0;1]) is out of the input texture
    bool isOutOfTexture(vec2 point) {
      if(point.x < 0.0 || point.x >= input_texture_size.x ||
         point.y < 0.0 || point.y >= input_texture_size.y)
        return true;
      else
        return false;
    }

    // Deals with floating point imprecisions
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    // Any computation involving the texture border is unreliable. Check if
    // this point is on a alpha == 0 component and return true if it is
    bool isOnTextureBorder(vec4 texel_color) {
      if(isAboutEqual(texel_color.a, 0.0))
        return true;
      else
        return false;
    }

    vec4 calculateKernelRows(vec2 l_du, vec2 l_dv, vec2 r_du, vec2 r_dv) {
      vec4 result = vec4(0.0, 0.0, 0.0, 1.0); // RGB results and alpha factor
      float inc = 1.0;
      for (int i = 0; i < 10; ++i) {
        vec2 l_point = pass_TextureCoord + l_du + (inc * l_dv);
        vec2 r_point = pass_TextureCoord + r_du + (inc * r_dv);
                
        vec4 l_rgba = texture2D(input_texture, l_point);
        vec4 r_rgba = texture2D(input_texture, r_point);

        result.a *= l_rgba.a * r_rgba.a; // Store alpha factor

        result.xyz += abs(r_rgba.xyz - l_rgba.xyz);
        
        inc += 1.0;
      }
      return result;
    }

    float calculateTotalKernelResponse(vec2 du, vec2 dv) {

      vec4 result = vec4(0.0, 0.0, 0.0, 1.0); // RGB responses per each pixel plus alpha factor response

      // Remember that with increments of 3째 each the kernel should be
      // longer than 19 pixels

      //
      // float sobel_kernel[9];
      // sobel_kernel[0] = -1.0; sobel_kernel[1] = 0.0; sobel_kernel[2] = +1.0;
      // sobel_kernel[3] = -1.5; sobel_kernel[4] = 0.0; sobel_kernel[5] = +1.5;
      // sobel_kernel[6] = -1.0; sobel_kernel[7] = 0.0; sobel_kernel[8] = +1.0;

      // << Row 1 and extensions above it >>
        
      vec4 rows_result = calculateKernelRows(-du, -dv, +du, -dv);
      result.xyz += rows_result.xyz;
      result.a *= rows_result.a;

      // << Row 2 - central row >>

      vec2 r_point = pass_TextureCoord + du; // Texture texel to be multiplied with kernel position 5
      vec2 l_point = pass_TextureCoord - du; // ditto with kernel pos 3
        
      vec4 l_rgba = texture2D(input_texture, l_point);
      vec4 r_rgba = texture2D(input_texture, r_point);        

      result.a *= l_rgba.a * l_rgba.a;
      result.xyz += 1.5 * abs(r_rgba.xyz - l_rgba.xyz);

      // << Row 2 and extensions below it >>
        
      rows_result = calculateKernelRows(-du, +dv, +du, +dv);
      result.xyz += rows_result.xyz;
      result.a *= rows_result.a;
        
      // Apply the alpha factors (1.0 if everything is included into the
      // computation, 0.0 if something triggered a no-compute for this kernel)
      result *= result.a;

      // Sum all responses before thresholding and normalize it in the
      // range [0.0;1.0] (max for the kernel is 10 * 3.0 + 1 * 1.5 * 3.0 + 10 * 3.0 = 64.5)
      return abs(result.x + result.y + result.z) / 64.5;
    }

    void main(void) {

      vec4 response = vec4(0.0, 0.0, 0.0, 0.0);
      //                   ^^^  ^^^
      //                   |||  |||
      //                   |||  bin (if response is 1)
      //                   response

      float phase1_threshold = 0.4;

      int phase1_strongest_bin = -1; // -1 means no bin had a strong response
      float phase1_strongest_response = 0.0;

      // Step 1 - first 12 bins to detect stronger response

      for (int i = 0; i < 12; ++i) {

        vec2 du = rotation_du[5 * i]; // Grab one of the 12 primary vectors
        vec2 dv = vec2(du.y, -du.x);  // Obtain the perpendicular vector
        
        float bin_response = calculateTotalKernelResponse(du, dv) * response_boost[5 * i];

        bin_response = applyThreshold(bin_response, phase1_threshold);

        // Detect if we had the strongest response for this bin
        if (bin_response > phase1_strongest_response) {
          phase1_strongest_response = bin_response;
          phase1_strongest_bin = i;
        }
      }

      float phase2_threshold = 0.72;

      int phase2_strongest_bin = -1; // -1 means no bin had a strong response
      float phase2_strongest_response = 0.0;

      // Step 2 - refine to detect fine-grained strongest response bin
      
      if (phase1_strongest_bin != -1) {

        for (int i = -2; i <= 2; ++i) {
          int sub_bin = (5 * phase1_strongest_bin) + i;

          // Wrap around in the [0;60[ interval
          if (sub_bin < 0)
            sub_bin += 60;
          sub_bin = sub_bin - ((sub_bin / 60) * 60); // No modulo in ES 2.0

          vec2 du;
          vec2 dv;
          float response_boost_float = 0.0;
          for(int i2=0; i2<60; ++i2){ // Wasteful stupid way to overcome ES 2.0
                                      // limitations on accessing rotation_du[sub_bin]
            if(i2 == sub_bin) {
              du = rotation_du[i2]; // Grab refined secondary vector
              dv = vec2(du.y, -du.x);    // Obtain the perpendicular vector
              response_boost_float = response_boost[i2];
              break;
            }
          }

          float bin_response = calculateTotalKernelResponse(du, dv);

          bin_response = applyThreshold(bin_response, phase2_threshold) * response_boost_float;

          // Detect if we had the strongest response for this bin
          if (bin_response > phase2_strongest_response) {
            phase2_strongest_response = bin_response;
            phase2_strongest_bin = sub_bin;
          }
        }

        if (phase2_strongest_bin != -1) {
          // Success - we had a strong response for one refined bin
          response.x = 1.0;
          response.y = (1.0 / 60.0) * float(phase2_strongest_bin);
        }
      }
     
      gl_FragColor = response;
    }
  </script>

  <!-- Reduction shader -->
  <script id="row-reduction-shader-fs" type="x-shader/x-fragment">
    // Reduces a WxH texture data outputting X float values for X angles each time
    precision highp float;

    uniform sampler2D input_texture;
    uniform vec2 input_texture_size;

    varying vec4 pass_Color; // Unused/for debugging purposes
    varying vec2 pass_TextureCoord;

    // Deals with floating point imprecisions
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    vec4 packFloatToVec4i(const float value) {
      const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
      const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
      vec4 res = fract(value * bitSh);
      res -= res.xxyz * bitMsk;
      return res;
    }

    float unpackFloatFromVec4i(const vec4 value) {
      const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
      return(dot(value, bitSh));
    }

    void main(void) {

      float pixels_count = 0.0;

      float my_bin = pass_TextureCoord.x;

      for(float y = 0.0; y < 512.0; ++y) {

        for(float x = 0.0; x < 512.0; ++x) {
    
          vec4 pixel_result = texture2D(input_texture, vec2(x / 512.0 + (1.0/512.0)/2.0, y / 512.0 + (1.0/512.0)/2.0));

          if(isAboutEqual(pixel_result.x, 1.0)) {
            // There was a response for this pixel, check if it's in our bin
            float bin = pixel_result.y;
            if(isAboutEqual(bin, my_bin))
              ++pixels_count;
          }
        }
      }

      // Normalize the values on the entire texture
      pixels_count /= (512.0 * 512.0);

      // First one is the percentage of pixels that responded to the filter
      gl_FragColor = packFloatToVec4i(pixels_count);
    }

  </script>

  <!-- Visual feedback output -->
  <script id="visual-feedback-fs" type="x-shader/x-fragment">
    // Outputs the detected angles with some colors, aids in debugging
    precision highp float;
    uniform sampler2D input_texture;
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;
    
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    void main(void) {
      
      vec4 pixel = texture2D(input_texture, pass_TextureCoord);
      if(isAboutEqual(pixel.x, 1.0)) {
        // Response for this pixel
        float bin = pixel.y * 60.0; // [0; 59]
        vec3 color;
        if(isAboutEqual(bin, 15.0)) // 45
          color = vec3(0.0, 1.0, 0.0);
        else if(isAboutEqual(bin, 45.0)) // 135
          color = vec3(0.0, 1.0, 0.0);
        else
          color = vec3(1.0, 0.0, 0.0);
          
        gl_FragColor = vec4(color.rgb, 1.0);
      } else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);      
    }
  </script>
  
  <!-- Output in unsigned byte for CPU reduction -->
  <script id="histogram-cpu-fs" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D input_texture;
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;
    
    void main(void) {      
      vec4 pixel = texture2D(input_texture, pass_TextureCoord);
      gl_FragColor = pixel;      
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance
    
    // Raphael graph stuff
    var raphael_div;
    var raphael_chart;
    var histogramBarsColors = []; // Needed to fix g.raphael/issues/44
    
    function pageInitialization() {
      var canvas = document.getElementById("filter-canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
        return;
      }
   
      var fptex_supported = gl.getExtension('OES_texture_float'); // Enable floating point textures
      if (fptex_supported == null) {
        alert("Floating point textures extension not supported");
        return;
      }

      setupQuad();
      initFramebuffer();
      initShaderPrograms();
      initTextures();
      
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      // Also set up Raphael histogram div      
      raphael_div = Raphael("histogram-bars");
      
      for(var i = 0; i < 60; ++i) {
        histogramBarsColors.push("hsb(" + Math.random()*0.36 +  "," + Math.random() +  ", " + (0.5+Math.random()/2) +  ")");
      }
      
      var empty_array = new Float32Array(60);
      raphael_chart = raphael_div.barchart(10, 10, 1000, 200, empty_array, {colors: histogramBarsColors });
    }
    
    // Geometric and quad rendering data
    var vboId;  // Quad data
    var vboiId; // Quad indices
    var indices_count;
    var mvMatrix = mat4.create(); // Warning: does not default to identity
    var pMatrix = mat4.create();  // Warning: does not default to identity

    // Input texture
    var textureId;
    var imageDimensions = [0.0, 0.0];
    var textureIsSafeToRender = false; // Indicates whether the texture has been loaded

    // Distortion correction factors
    var alphax = 0.0;
    var alphay = 0.0;
    var maximum_alpha = 0.25;

    // Shader programs
    var undistortionShaderProgram; // Applies the undistortion filtering
    var histogramComputerShaderProgram; // Calculates the edge histogram
    var histogramReductionShaderProgram; // Reduces an histogram texture to a single row
    var neuterProgram; // Just visualizes a texture
    var histogramFeedbackProgram; // Visualizes the histogram calculation output

    // Secondary framebuffers for intermediate computations and textures
    var renderFrameBuffer;
    var undistortionTexture;
    var histogram_responses;
    var histogram_reduced_row;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    // Init the undistortion framebuffer and its texture
    function initFramebuffer() {
      renderFrameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);
      renderFrameBuffer.width = 512;
      renderFrameBuffer.height = 512;

      var renderbuffer;
      renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderFrameBuffer.width, renderFrameBuffer.height);
      renderFrameBuffer.renderBuffer = renderbuffer; // Save it for later use

      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
      
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function attachTextureToFrameBuffer(texture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function initShaderPrograms() {
      // ~-~-~-~-~-~-~- Init the undistortion shader program ~-~-~-~-~-~-~-
      var fragmentShader = getShader(gl, "undistortion-shader-fs");
      var vertexShader = getShader(gl, "neuter-shader-vs");
      undistortionShaderProgram = gl.createProgram();
      gl.attachShader(undistortionShaderProgram, vertexShader);
      gl.attachShader(undistortionShaderProgram, fragmentShader);
      gl.linkProgram(undistortionShaderProgram);
      if (!gl.getProgramParameter(undistortionShaderProgram, gl.LINK_STATUS)) {
          alert("Could not initialize shaders");
      }
      gl.useProgram(undistortionShaderProgram);
      // Enable vertex attribute arrays for position, color, uvs
      undistortionShaderProgram.inPosition = gl.getAttribLocation(undistortionShaderProgram, "in_Position");
      gl.enableVertexAttribArray(undistortionShaderProgram.inPosition);
      undistortionShaderProgram.inColor = gl.getAttribLocation(undistortionShaderProgram, "in_Color");
      gl.enableVertexAttribArray(undistortionShaderProgram.inColor);
      undistortionShaderProgram.inTextureCoord = gl.getAttribLocation(undistortionShaderProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(undistortionShaderProgram.inTextureCoord);
      // Bind uniforms for matrices
      undistortionShaderProgram.pMatrixUniform = gl.getUniformLocation(undistortionShaderProgram, "uPMatrix");
      undistortionShaderProgram.mvMatrixUniform = gl.getUniformLocation(undistortionShaderProgram, "uMVMatrix");
      // Bind uniform for image dimensions and alpha factors
      undistortionShaderProgram.imageDimensionsUniform = gl.getUniformLocation(undistortionShaderProgram, "image_dimensions");
      undistortionShaderProgram.alphax = gl.getUniformLocation(undistortionShaderProgram, "alphax");
      undistortionShaderProgram.alphay = gl.getUniformLocation(undistortionShaderProgram, "alphay");
      
      // ~-~-~-~-~-~-~- Init the histogram computer shader program ~-~-~-~-~-~-~-
      
      var edgeFragmentShader = getShader(gl, "histogram-computer-shader-fs");
      var edgeVertexShader = getShader(gl, "neuter-shader-vs");
      histogramComputerShaderProgram = gl.createProgram();
      gl.attachShader(histogramComputerShaderProgram, edgeVertexShader);
      gl.attachShader(histogramComputerShaderProgram, edgeFragmentShader);
      gl.linkProgram(histogramComputerShaderProgram);
      if (!gl.getProgramParameter(histogramComputerShaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(histogramComputerShaderProgram);
      histogramComputerShaderProgram.inPosition = gl.getAttribLocation(histogramComputerShaderProgram, "in_Position");
      gl.enableVertexAttribArray(histogramComputerShaderProgram.inPosition);
      histogramComputerShaderProgram.inColor = gl.getAttribLocation(histogramComputerShaderProgram, "in_Color");
      gl.enableVertexAttribArray(histogramComputerShaderProgram.inColor);
      histogramComputerShaderProgram.inTextureCoord = gl.getAttribLocation(histogramComputerShaderProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(histogramComputerShaderProgram.inTextureCoord);
      histogramComputerShaderProgram.pMatrixUniform = gl.getUniformLocation(histogramComputerShaderProgram, "uPMatrix");
      histogramComputerShaderProgram.mvMatrixUniform = gl.getUniformLocation(histogramComputerShaderProgram, "uMVMatrix");
      histogramComputerShaderProgram.texture_size = gl.getUniformLocation(histogramComputerShaderProgram, "input_texture_size");
      histogramComputerShaderProgram.rotation_du = gl.getUniformLocation(histogramComputerShaderProgram, "rotation_du");
      histogramComputerShaderProgram.response_boost = gl.getUniformLocation(histogramComputerShaderProgram, "response_boost");

      // ~-~-~-~-~-~-~- Init the histogram GPU reduction shader program ~-~-~-~-~-~-~-

      var rowReductionFragmentShader = getShader(gl, "row-reduction-shader-fs");
      var rowReductionVertexShader = getShader(gl, "neuter-shader-vs");
      histogramReductionShaderProgram = gl.createProgram();
      gl.attachShader(histogramReductionShaderProgram, rowReductionVertexShader);
      gl.attachShader(histogramReductionShaderProgram, rowReductionFragmentShader);
      gl.linkProgram(histogramReductionShaderProgram);
      if (!gl.getProgramParameter(histogramReductionShaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(histogramReductionShaderProgram);
      histogramReductionShaderProgram.inPosition = gl.getAttribLocation(histogramReductionShaderProgram, "in_Position");
      gl.enableVertexAttribArray(histogramReductionShaderProgram.inPosition);
      histogramReductionShaderProgram.inColor = gl.getAttribLocation(histogramReductionShaderProgram, "in_Color");
      gl.enableVertexAttribArray(histogramReductionShaderProgram.inColor);
      histogramReductionShaderProgram.inTextureCoord = gl.getAttribLocation(histogramReductionShaderProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(histogramReductionShaderProgram.inTextureCoord);
      histogramReductionShaderProgram.pMatrixUniform = gl.getUniformLocation(histogramReductionShaderProgram, "uPMatrix");
      histogramReductionShaderProgram.mvMatrixUniform = gl.getUniformLocation(histogramReductionShaderProgram, "uMVMatrix");
      histogramReductionShaderProgram.texture_size = gl.getUniformLocation(histogramReductionShaderProgram, "input_texture_size");

      // ~-~-~-~-~-~-~- Init the neuter shader program ~-~-~-~-~-~-~-

      var neuterFragmentShader = getShader(gl, "neuter-shader-fs");
      var neuterVertexShader = getShader(gl, "neuter-shader-vs");
      neuterProgram = gl.createProgram();
      gl.attachShader(neuterProgram, neuterVertexShader);
      gl.attachShader(neuterProgram, neuterFragmentShader);
      gl.linkProgram(neuterProgram);
      if (!gl.getProgramParameter(neuterProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(neuterProgram);
      neuterProgram.inPosition = gl.getAttribLocation(neuterProgram, "in_Position");
      gl.enableVertexAttribArray(neuterProgram.inPosition);
      neuterProgram.inColor = gl.getAttribLocation(neuterProgram, "in_Color");
      gl.enableVertexAttribArray(neuterProgram.inColor);
      neuterProgram.inTextureCoord = gl.getAttribLocation(neuterProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(neuterProgram.inTextureCoord);
      neuterProgram.pMatrixUniform = gl.getUniformLocation(neuterProgram, "uPMatrix");
      neuterProgram.mvMatrixUniform = gl.getUniformLocation(neuterProgram, "uMVMatrix");
      
      
      // ~-~-~-~-~-~-~- Init the histogram feedback shader program ~-~-~-~-~-~-~-

      var feedbackFragmentShader = getShader(gl, "visual-feedback-fs");
      var neuterVertexShader = getShader(gl, "neuter-shader-vs");
      histogramFeedbackProgram = gl.createProgram();
      gl.attachShader(histogramFeedbackProgram, neuterVertexShader);
      gl.attachShader(histogramFeedbackProgram, feedbackFragmentShader);
      gl.linkProgram(histogramFeedbackProgram);
      if (!gl.getProgramParameter(histogramFeedbackProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(histogramFeedbackProgram);
      histogramFeedbackProgram.inPosition = gl.getAttribLocation(histogramFeedbackProgram, "in_Position");
      gl.enableVertexAttribArray(histogramFeedbackProgram.inPosition);
      histogramFeedbackProgram.inColor = gl.getAttribLocation(histogramFeedbackProgram, "in_Color");
      gl.enableVertexAttribArray(histogramFeedbackProgram.inColor);
      histogramFeedbackProgram.inTextureCoord = gl.getAttribLocation(histogramFeedbackProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(histogramFeedbackProgram.inTextureCoord);
      histogramFeedbackProgram.pMatrixUniform = gl.getUniformLocation(histogramFeedbackProgram, "uPMatrix");
      histogramFeedbackProgram.mvMatrixUniform = gl.getUniformLocation(histogramFeedbackProgram, "uMVMatrix");
    }
    
    function setupQuad() {
      // Set up VBO with quad data
      vboId = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      var vbo_data = [
        -1.0, 1.0, -1.0, 1.0,   // Vertex (xyzw)
        1.0, 0.0, 0.0, 1.0,     // RGBA
        0.0, 1.0,               // UV coords
        
        -1.0, -1.0, -1.0, 1.0,  // Vertex (xyzw)
        0.0, 1.0, 0.0, 1.0,     // RGBA
        0.0, 0.0,               // UV coords
        
        1.0, -1.0, -1.0, 1.0,   // Vertex (xyzw)
        0.0, 0.0, 1.0, 1.0,     // RGBA
        1.0, 0.0,               // UV coords
        
        1.0, 1.0, -1.0, 1.0,    // Vertex (xyzw)
        1.0, 1.0, 1.0, 1.0,     // RGBA
        1.0, 1.0                // UV coords
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      // Set up VBO with indices data
      vboiId = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);
      var indices = [
        0, 1, 2,
        2, 3, 0
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      indices_count = indices.length;      
    }    

    function initTextures() {
      // ~-~-~-~-~-~- Input texture ~-~-~-~-~-~-
      textureId = gl.createTexture();
      textureId.image = new Image();
      textureId.image.onload = function () {
        gl.bindTexture(gl.TEXTURE_2D, textureId);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureId.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
        textureIsSafeToRender = true;
      }
      textureId.image.src = "assets/pincushion_distortion_45_2.png";
      imageDimensions = new Float32Array([textureId.image.width, textureId.image.height]);

      // ~-~-~-~-~-~- Undistorted texture ~-~-~-~-~-~-
      undistortionTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, undistortionTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderFrameBuffer.width,
                                             renderFrameBuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      gl.bindTexture(gl.TEXTURE_2D, null);

      // ~-~-~-~-~-~- Histogram computing textures ~-~-~-~-~-~-
      histogram_responses = gl.createTexture();
      
      var setTextureSize = function () {
        ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderFrameBuffer.width,
                                               renderFrameBuffer.height, 0, gl.RGBA, gl.FLOAT, null));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      }

      gl.bindTexture(gl.TEXTURE_2D, histogram_responses);
      setTextureSize();

      gl.bindTexture(gl.TEXTURE_2D, null);

      // ~-~-~-~-~-~- Reduction textures ~-~-~-~-~-~-
      histogram_reduced_row = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, histogram_reduced_row);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      // 60 bins x 1 output (one row)
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 60, // 60 bins - one row is sufficient
                                             1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Render an undistorted image in the framebuffer texture
    function renderUndistortedInFramebuffer() {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Makes sure we're rendering the entire texture (this will LATER be mapped to the viewport)
      gl.viewport(0, 0, 512, 512);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     

      // Set up undistortion shader program
      gl.useProgram(undistortionShaderProgram);

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(undistortionShaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(undistortionShaderProgram.mvMatrixUniform, false, mvMatrix);

      // ------------ Filtering-specific data ------------
      // Set image dimensions uniform
      gl.uniform2fv(undistortionShaderProgram.imageDimensionsUniform, imageDimensions);

      // Set alpha factors uniforms
      gl.uniform1fv(undistortionShaderProgram.alphax, new Float32Array([alphax]));
      gl.uniform1fv(undistortionShaderProgram.alphay, new Float32Array([alphay]));
      // --------------------------------------------------

      // Bind texture to texture unit 0
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, textureId);
      var sampler2D_loc = gl.getUniformLocation(undistortionShaderProgram, "texture_diffuse");
      gl.uniform1i(sampler2D_loc, 0);

      // Bind vertex data and set vertex attributes (as from a VAO)
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(undistortionShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(undistortionShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(undistortionShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);

      // Bind vertex index info
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);

      // Draw the quad
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      // Cleanup
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Calculates histogram data. 'response_part' is the histogram part that
    // has to be calculated (see the fragment shader for more info)
    function calculateHistogramDataInFramebuffer() {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Makes sure we're rendering the entire texture
      gl.viewport(0, 0, 512, 512);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Set up histogram calculator shader program
      gl.useProgram(histogramComputerShaderProgram);

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(histogramComputerShaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(histogramComputerShaderProgram.mvMatrixUniform, false, mvMatrix);

      // Set texture size uniforms
      var texture_size_array = [512.0, 512.0];
      gl.uniform2fv(histogramComputerShaderProgram.texture_size, texture_size_array);

      // Bind texture to texture unit 0
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, undistortionTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      //gl.bindTexture(gl.TEXTURE_2D, textureId); // DEBUG DEBUG DEBUG
      var sampler2D_loc = gl.getUniformLocation(histogramComputerShaderProgram, "input_texture");
      gl.uniform1i(sampler2D_loc, 0);

      // Fill the angle increments for the histogram computer shader      
      var vectors = new Float32Array(12 * 5 * 2); // 60 vec2 increments, (see fragment shader)
      var angle_increment_degrees = 3.0;
      for (i = 0; i < 12 * 5; ++i) {
        var angle_radians = (i * angle_increment_degrees) / 180.0 * Math.PI;

        vectors[i * 2] = Math.cos(angle_radians) / 512.0;
        vectors[i * 2 + 1] = Math.sin(angle_radians) / 512.0;
      }
      gl.uniform2fv(histogramComputerShaderProgram.rotation_du, vectors);

      // Fill response boost
      var response_boost = new Float32Array(12 * 5);
      for (i = 0; i < 12 * 5; ++i) {
        var angle = i * angle_increment_degrees;
        if (Math.floor(angle / 45) % 2) // is odd
          response_boost[i] = 1 + ((Math.sqrt(2) - 1) * ((45 - (angle % 45)) / 45));
        else
          response_boost[i] = 1 + ((Math.sqrt(2) - 1) * ((angle % 45) / 45));
      }
      gl.uniform1fv(histogramComputerShaderProgram.response_boost, response_boost);

      // Bind vertex data and set vertex attributes (as from a VAO)
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(histogramComputerShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(histogramComputerShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(histogramComputerShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);

      // Bind vertex index info
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);

      // Draw the quad
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      // Cleanup
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Computes a reduction to one row for the histogram data
    function histogramReductionInFramebuffer() {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Resize secondary framebuffer depth buffer to accommodate for the Wx1 output texture
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderFrameBuffer.renderBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 60, 1);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);

      // Sets only one row of bins to be computed
      gl.viewport(0, 0, 60, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Set up histogram reduction shader program
      gl.useProgram(histogramReductionShaderProgram);

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(histogramReductionShaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(histogramReductionShaderProgram.mvMatrixUniform, false, mvMatrix);

      // Set input texture size uniforms
      var texture_size_array = [512.0, 512.0];
      gl.uniform2fv(histogramReductionShaderProgram.texture_size, texture_size_array);

      // [obsolete since the entire loop runs in one step now] Set reduction part
      // gl.uniform1f(histogramReductionShaderProgram.response_part, histogram_part);

      // Bind the right texture input to texture unit 0
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, histogram_responses);
      // Since these are data textures, in order to facilitate lookup set nearest filters
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      var sampler2D_loc = gl.getUniformLocation(histogramReductionShaderProgram, "input_texture");
      gl.uniform1i(sampler2D_loc, 0);      

      // Bind vertex data and set vertex attributes (as from a VAO)
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(histogramReductionShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(histogramReductionShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(histogramReductionShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);

      // Bind vertex index info
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);

      // Draw the quad
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      // Cleanup
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);      

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      // Also restore normal depth buffer
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderFrameBuffer.renderBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderFrameBuffer.width, renderFrameBuffer.height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
  
    // Given a reduced texture row (histogram data) reduces this on the CPU to a
    // simple array of 60 float angles
    function getComponentsFromReducedTexture(texture) {
      // Create a framebuffer backed by the supplied texture
      var framebuffer;
      framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

      var renderbuffer;
      renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 60, 1);
      framebuffer.renderBuffer = renderbuffer;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      // Read the contents of the texture from the framebuffer
      var data_uint8 = new Uint8Array(60 * 1 * 4); // 60 bin responses, each one packed into 4 8-bit components
      gl.readPixels(0, 0, 60, 1, gl.RGBA, gl.UNSIGNED_BYTE, data_uint8);
      var result_angles = new Float32Array(60);

      // Equivalent to the GLSL unpackFloatFromVec4i()
      for (var i = 0; i < 60; ++i) {
        var bitSh = [1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0];
        var result = 0.0;
        for(var j = 0; j < 4; ++j)
          result += (data_uint8[i * 4 + j] / 256.0) * bitSh[j];
        result_angles[i] = result;
      }
      gl.deleteFramebuffer(framebuffer);
      return result_angles;
    }
    
    
    function histogramReductionCPU() {
    
      var visualFeedbackProgram;
      var fragment_shader = getShader(gl, "histogram-cpu-fs");
      var vertex_shader = getShader(gl, "neuter-shader-vs");
      visualFeedbackProgram = gl.createProgram();
      gl.attachShader(visualFeedbackProgram, vertex_shader);
      gl.attachShader(visualFeedbackProgram, fragment_shader);
      gl.linkProgram(visualFeedbackProgram);
      if (!gl.getProgramParameter(visualFeedbackProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(visualFeedbackProgram);
      visualFeedbackProgram.inPosition = gl.getAttribLocation(visualFeedbackProgram, "in_Position");
      gl.enableVertexAttribArray(visualFeedbackProgram.inPosition);
      visualFeedbackProgram.inColor = gl.getAttribLocation(visualFeedbackProgram, "in_Color");
      gl.enableVertexAttribArray(visualFeedbackProgram.inColor);
      visualFeedbackProgram.inTextureCoord = gl.getAttribLocation(visualFeedbackProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(visualFeedbackProgram.inTextureCoord);
      visualFeedbackProgram.pMatrixUniform = gl.getUniformLocation(visualFeedbackProgram, "uPMatrix");
      visualFeedbackProgram.mvMatrixUniform = gl.getUniformLocation(visualFeedbackProgram, "uMVMatrix");

      var output_8bit_texture;
      output_8bit_texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, output_8bit_texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512,
                                             512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      gl.bindTexture(gl.TEXTURE_2D, null);
    
      attachTextureToFrameBuffer(output_8bit_texture);
      

      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);
      gl.viewport(0, 0, 512, 512);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(visualFeedbackProgram);
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(visualFeedbackProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(visualFeedbackProgram.mvMatrixUniform, false, mvMatrix);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, histogram_responses);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      var sampler2D_loc = gl.getUniformLocation(visualFeedbackProgram, "input_texture");
      gl.uniform1i(sampler2D_loc, 0);

      // Bind vertex data and set vertex attributes (as from a VAO)
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(visualFeedbackProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(visualFeedbackProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(visualFeedbackProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);

      // Draw the quad
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      // CPU-calculate histogram
      var histogram = new Float32Array(60);
        
      var width = 512.0;
      var height = 512.0;
      var data = new Uint8Array(width * height * 4);
      var data_flipped = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
      // Flip webgl data (usually Y-inverse stored)
      for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
          data_flipped[y * width * 4 + x * 4] = data[(height - 1 - y) * width * 4 + x * 4];
          data_flipped[y * width * 4 + x * 4 + 1] = data[(height - 1 - y) * width * 4 + x * 4 + 1];
          data_flipped[y * width * 4 + x * 4 + 2] = data[(height - 1 - y) * width * 4 + x * 4 + 2];
          data_flipped[y * width * 4 + x * 4 + 3] = data[(height - 1 - y) * width * 4 + x * 4 + 3];
        }
      }
      
      // Calculate histogram
      for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
          if(data_flipped[y * width * 4 + x * 4] > 0.0) {
            var bin = Math.floor((data_flipped[y * width * 4 + x * 4 + 1] / 255) * 60);
            histogram[bin] += 1.0;
          }
        }
      }

      // Cleanup
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      
      return histogram;
    }
    
    function outputVisualFeedback() {
      var visualFeedbackProgram;
      var fragment_shader = getShader(gl, "visual-feedback-fs");
      var vertex_shader = getShader(gl, "neuter-shader-vs");
      visualFeedbackProgram = gl.createProgram();
      gl.attachShader(visualFeedbackProgram, vertex_shader);
      gl.attachShader(visualFeedbackProgram, fragment_shader);
      gl.linkProgram(visualFeedbackProgram);
      if (!gl.getProgramParameter(visualFeedbackProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      gl.useProgram(visualFeedbackProgram);
      visualFeedbackProgram.inPosition = gl.getAttribLocation(visualFeedbackProgram, "in_Position");
      gl.enableVertexAttribArray(visualFeedbackProgram.inPosition);
      visualFeedbackProgram.inColor = gl.getAttribLocation(visualFeedbackProgram, "in_Color");
      gl.enableVertexAttribArray(visualFeedbackProgram.inColor);
      visualFeedbackProgram.inTextureCoord = gl.getAttribLocation(visualFeedbackProgram, "in_TextureCoord");
      gl.enableVertexAttribArray(visualFeedbackProgram.inTextureCoord);
      visualFeedbackProgram.pMatrixUniform = gl.getUniformLocation(visualFeedbackProgram, "uPMatrix");
      visualFeedbackProgram.mvMatrixUniform = gl.getUniformLocation(visualFeedbackProgram, "uMVMatrix");

      var output_8bit_texture;
      output_8bit_texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, output_8bit_texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512,
                                             512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      gl.bindTexture(gl.TEXTURE_2D, null);
    
      attachTextureToFrameBuffer(output_8bit_texture);
      

      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);
      gl.viewport(0, 0, 512, 512);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(visualFeedbackProgram);
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(visualFeedbackProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(visualFeedbackProgram.mvMatrixUniform, false, mvMatrix);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, histogram_responses);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      var sampler2D_loc = gl.getUniformLocation(visualFeedbackProgram, "input_texture");
      gl.uniform1i(sampler2D_loc, 0);

      // Bind vertex data and set vertex attributes (as from a VAO)
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(visualFeedbackProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(visualFeedbackProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(visualFeedbackProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);

      // Draw the quad
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      
    
      // Draw into the debug texture
        
      // only retain angles data
      var width = 512.0;
      var height = 512.0;
      var data = new Uint8Array(width * height * 4);
      var data_flipped = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
      // Flip webgl data (usually Y-inverse stored)
      for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
          data_flipped[y * width * 4 + x * 4] = data[(height - 1 - y) * width * 4 + x * 4];
          data_flipped[y * width * 4 + x * 4 + 1] = data[(height - 1 - y) * width * 4 + x * 4 + 1];
          data_flipped[y * width * 4 + x * 4 + 2] = data[(height - 1 - y) * width * 4 + x * 4 + 2];
          data_flipped[y * width * 4 + x * 4 + 3] = data[(height - 1 - y) * width * 4 + x * 4 + 3];
        }
      }

      // Create a 2D canvas to store the result 
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext('2d');

      // Copy the pixels to a 2D canvas
      var imageData = context.createImageData(width, height);
      imageData.data.set(data_flipped);
      context.putImageData(imageData, 0, 0);

      // Cleanup
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      
      return canvas.toDataURL();
    }

    function displayHistogramInBarChart(histogram) {
      // Scale up these values to indicate how many pixels responded to a given angle      
      for (var i = 0; i < histogram.length; ++i) {
        histogram[i] = 512.0 * 512.0 * histogram[i];
      }
    
      raphael_chart.remove();  
      raphael_chart = raphael_div.barchart(10, 10, 1000, 200, histogram, {colors: histogramBarsColors });
    }

    function estimateHistogram() {
      
      if(textureIsSafeToRender == false)
        return []; // Still can't render stuff if the texture hasn't been loaded yet

      // First render an undistorted image in the framebuffer texture
      attachTextureToFrameBuffer(undistortionTexture);
      renderUndistortedInFramebuffer();

      // Render and calculate all the histogram responses
      attachTextureToFrameBuffer(histogram_responses);
      calculateHistogramDataInFramebuffer();

      // Now reduce all the responses on the GPU
      attachTextureToFrameBuffer(histogram_reduced_row); // Output into this
      histogramReductionInFramebuffer();

      var histogram = getComponentsFromReducedTexture(histogram_reduced_row);
      
      
      // Output both the undistorted texture and the histogram-response texture in the same canvas
 
      gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Default framebuffer
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth / 2, gl.viewportHeight);
      gl.useProgram(neuterProgram);
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(neuterProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(neuterProgram.mvMatrixUniform, false, mvMatrix);
      gl.activeTexture(gl.TEXTURE0);      
      gl.bindTexture(gl.TEXTURE_2D, undistortionTexture);
      var sampler2D_loc = gl.getUniformLocation(neuterProgram, "texture_diffuse");
      gl.uniform1i(sampler2D_loc, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(neuterProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(neuterProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(neuterProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      gl.viewport(gl.viewportWidth / 2, 0, gl.viewportWidth / 2, gl.viewportHeight);
      gl.useProgram(histogramFeedbackProgram);
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      gl.uniformMatrix4fv(histogramFeedbackProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(histogramFeedbackProgram.mvMatrixUniform, false, mvMatrix);
      gl.activeTexture(gl.TEXTURE0);      
      gl.bindTexture(gl.TEXTURE_2D, histogram_responses);
      var sampler2D_loc = gl.getUniformLocation(histogramFeedbackProgram, "input_texture");
      gl.uniform1i(sampler2D_loc, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
      gl.vertexAttribPointer(histogramFeedbackProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0);
      gl.vertexAttribPointer(histogramFeedbackProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4);
      gl.vertexAttribPointer(histogramFeedbackProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId);
      gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);

      // Display the histogram with Raphael.js
      displayHistogramInBarChart(histogram);
      
      return histogram; // Return data for optimal estimate
    }

    /**
     * The main calibration routine     
     */
    function calibration() {

      var best_score_found = -1000.0;
      var best_alpha = 0;

      // Start a series of calibrations by providing undistortion parameters

      var alpha = 1;

      function calibrationSummary() {
        alphax = (best_alpha * 0.01) * maximum_alpha;
        alphay = alphax;
        statusLog("Calibration done, best estimation for parameter " + best_alpha);
        estimateHistogram();
      }

      function calibrateForAlpha() {
        statusLog("Calibrating distortion filtering [" + Math.floor(alpha / 150 * 100) + "%]...");
        alphax = (alpha * 0.01) * maximum_alpha;
        alphay = alphax;

        var histogram = estimateHistogram();
        while(histogram.length == 0)
          calibrateForAlpha(); // Wait for the images to be fully loaded

        // Assign a score to this histogram
        var score = Math.max.apply(Math, histogram) - Math.min.apply(Math, histogram);

        if (score > best_score_found) {
          statusLog("New best score found: " + score + " [" + alpha + "%]...");
          best_score_found = score;
          best_alpha = alpha;
        }

        ++alpha;

        if (alpha < 150)
          setTimeout(calibrateForAlpha, 0.8);
        else
          calibrationSummary();
      }

      calibrateForAlpha();
    }    
    
    // ~-~-~-~-~-~-~-~-~- UI related handling routines ~-~-~-~-~-~-~-~-~-

    function statusLog(text) {
      document.getElementById("text-status").textContent = text;
    }

    function startCalibration() {
      document.getElementById("calib_btn").hidden = true;
      calibration();
    }

    // ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
        
  </script>
</head>
<body onload="pageInitialization();">
  <button id="calib_btn" onclick="startCalibration();">Start calibration</button>
  <p id="text-status"></p>
  <div style="padding: 10px;">
    <div style="float: left;">
      <canvas id="filter-canvas" style="border: none;" width="1000" height="500"></canvas>
    </div>
  </div>
  <br />
  <div id="histogram-bars" style="width: 1000px; height: 200px;"/>
  <p id="debug-paragraph"></p>
  <!--
  <div style="display: block; padding: 20px">
    <img style="vertical-align:middle;" src="http://marcodiiga.github.io/images/webicon-github-m.png"/>
    <a href="https://github.com/marcodiiga/lens_distortion_filtering">Github Repo</a>
  </div>  
  -->
</body>
</html>