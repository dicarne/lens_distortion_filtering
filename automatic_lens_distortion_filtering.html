<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Radial lens undistortion filter</title>
  <script type="text/javascript" src="utils/glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>


  <script id="debug-fs" type="x-shader/x-fragment">
    // Debug fs
    precision mediump float;
    uniform sampler2D texture_diffuse;
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    void main(void) {
        gl_FragColor = texture2D(texture_diffuse, pass_TextureCoord);
    }
  </script>
  <script id="debug-vs" type="x-shader/x-vertex">    
    // Debug vs
    attribute vec4 in_Position;
    attribute vec4 in_Color;
    attribute vec2 in_TextureCoord;    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;
    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * in_Position;
      
      pass_Color = in_Color;
      pass_TextureCoord = in_TextureCoord;
    }
  </script>

  <!-- Radial distortion filter shaders  -->
  
  <script id="undistortion-shader-fs" type="x-shader/x-fragment">
    // Renders to the target framebuffer an undistorted version of the input
    // texture via an approximate radial undistortion filtering
    precision mediump float;
    
    uniform sampler2D texture_diffuse;
    uniform vec2 image_dimensions;
    uniform float alphax;
    uniform float alphay;
    
    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    // Deals with floating point imprecisions
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    void main(void) {
    
      // Normalize the u,v coordinates in the range [-1;+1]
      float x = (2.0 * pass_TextureCoord.x - 1.0) / 1.0;
      float y = (2.0 * pass_TextureCoord.y - 1.0) / 1.0;
      
      // Calculate l2 norm
      float r = x * x + y * y;
      
      // Calculate the deflated or inflated new coordinate (reverse transform)
      float x3 = x / (1.0 - alphax * r);
      float y3 = y / (1.0 - alphay * r); 
      float x2 = x / (1.0 - alphax * (x3 * x3 + y3 * y3));
      float y2 = y / (1.0 - alphay * (x3 * x3 + y3 * y3));	
      
      // Forward transform
      // float x2 = x * (1.0 - alphax * r);
      // float y2 = y * (1.0 - alphay * r);

      // De-normalize to the original range
      float i2 = (x2 + 1.0) * 1.0 / 2.0;
      float j2 = (y2 + 1.0) * 1.0 / 2.0;      
    
      if(i2 >= 0.0 && i2 <= 1.0 && j2 >= 0.0 && j2 <= 1.0) // If a valid texture coord
      {
        vec4 texture_color = texture2D(texture_diffuse, vec2(i2, j2));    

        // Important: borders are unreliable in lens correction (they incorrectly ramp up Sobel
        // kernel's response). In order to detect those we set the alpha value to 0
        // on the border of the input image before transferring it to the GPU

        float alpha = 1.0;
        if(isAboutEqual(i2, 0.0) || isAboutEqual(j2, 0.0) ||
           isAboutEqual(i2, 1.0) || isAboutEqual(j2, 1.0))
          alpha = 0.0;
            
        texture_color.a = alpha;

        gl_FragColor = texture_color; // Finally store the result
      } else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); // alpha is set to zero, i.e. don't compute
    }
  </script>
  <script id="neuter-shader-vs" type="x-shader/x-vertex">    
    // A neuter vertex shader, just passes XYZW, RGBA, UV coords to the
    // next fragment shader

    attribute vec4 in_Position;
    attribute vec4 in_Color;
    attribute vec2 in_TextureCoord;    

    varying vec4 pass_Color;
    varying vec2 pass_TextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * in_Position;
      
      pass_Color = in_Color;
      pass_TextureCoord = in_TextureCoord;
    }
  </script>
  
  <!-- Histogram computer shader -->
  <script id="histogram-computer-shader-fs" type="x-shader/x-fragment">
    // Computes part of an edge-response histogram in a texture
    precision mediump float;
    
    uniform sampler2D input_texture;
    uniform vec2 input_texture_size;

    //
    // Rotation vectors for the kernel. We're interested into covering a 360°
    // region for a pixel by rotating the sobel kernel multiple times. Since
    // we only care for edge directions and not orientation we'll sweep 180°
    // by using 15 degrees increments, i.e. 180/15 = 12 increments. To speed the
    // computation we precompute these vectors (as a couple of (x;y) vector
    // components) on the CPU and then pass it to the shader here.
    //
    uniform vec2 rotation_du[4];
    
    varying vec4 pass_Color; // Unused/for debugging purposes
    varying vec2 pass_TextureCoord;

    float applyThreshold(float value, float threshold) {
      if(value < threshold)
        value = 0.0;
       else
        value = 1.0; // Standardized response
      return value;
    }

    // Check if a point (range [0;1]) is out of the input texture
    bool isOutOfTexture(vec2 point) {
      if(point.x < 0.0 || point.x >= input_texture_size.x ||
         point.y < 0.0 || point.y >= input_texture_size.y)
        return true;
      else
        return false;
    }

    // Deals with floating point imprecisions
    bool isAboutEqual(float v1, float v2) {
      return abs(v1 - v2) < 0.01;
    }

    // Any computation involving the texture border is unreliable. Check if
    // this point is on a alpha == 0 component and return true if it is
    bool isOnTextureBorder(vec4 texel_color) {
      if(isAboutEqual(texel_color.a, 0.0))
        return true;
      else
        return false;
    }

    void main(void) {      
     
      vec4 angle_responses = vec4(0.0, 0.0, 0.0, 0.0);

      // Channel responses for this angle (alpha is not used)
      float result_r = 0.0;
      float result_g = 0.0;
      float result_b = 0.0;

      // Loop over all the rotation vectors (equivalent to rotating the kernel)
      for(int i = 0; i < 4; ++i) {
    
        result_r = 0.0;
        result_g = 0.0;
        result_b = 0.0;

        vec2 du = rotation_du[i];
        vec2 dv = vec2(du.y, -du.x); // Obtain the perpendicular vector

        //
        // float sobel_kernel[9];
        // sobel_kernel[0] = -1.0; sobel_kernel[1] = 0.0; sobel_kernel[2] = +1.0;
        // sobel_kernel[3] = -1.5; sobel_kernel[4] = 0.0; sobel_kernel[5] = +1.5;
        // sobel_kernel[6] = -1.0; sobel_kernel[7] = 0.0; sobel_kernel[8] = +1.0;

        // << Row 1 >>

        vec2 p1 = pass_TextureCoord + du - dv; // Texture texel to be multiplied with kernel position 2
        vec2 p2 = pass_TextureCoord - du - dv; // ditto with ker pos 0
        
        /*if(isOutOfTexture(p1) || isOutOfTexture(p2)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/
        
        vec4 p1_rgba = texture2D(input_texture, p1);
        vec4 p2_rgba = texture2D(input_texture, p2);

        /*if(isOnTextureBorder(p1_rgba) || isOnTextureBorder(p2_rgba)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/

        result_r += abs(p1_rgba.r - p2_rgba.r);
        result_g += abs(p1_rgba.g - p2_rgba.g);
        result_b += abs(p1_rgba.b - p2_rgba.b);

        // << Row 2 >>

        p1 = pass_TextureCoord + du; // Texture texel to be multiplied with kernel position 5
        p2 = pass_TextureCoord - du; // ditto with ker pos 3
        
        /*if(isOutOfTexture(p1) || isOutOfTexture(p2)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/
        
        p1_rgba = texture2D(input_texture, p1);
        p2_rgba = texture2D(input_texture, p2);
        
        /*if(isOnTextureBorder(p1_rgba) || isOnTextureBorder(p2_rgba)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/

        result_r += 1.5 * abs(p1_rgba.r - p2_rgba.r);
        result_g += 1.5 * abs(p1_rgba.g - p2_rgba.g);
        result_b += 1.5 * abs(p1_rgba.b - p2_rgba.b);

        // << Row 2 >>

        p1 = pass_TextureCoord + du + dv; // Texture texel to be multiplied with kernel position 8
        p2 = pass_TextureCoord - du + dv; // ditto with ker pos 6
        
        /*if(isOutOfTexture(p1) || isOutOfTexture(p2)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/
        
        p1_rgba = texture2D(input_texture, p1);
        p2_rgba = texture2D(input_texture, p2);
        
        /*if(isOnTextureBorder(p1_rgba) || isOnTextureBorder(p2_rgba)) {
          // Bail out (the response will be 0.0 for this angle)
          continue;
        }*/

        result_r += abs(p1_rgba.r - p2_rgba.r);
        result_g += abs(p1_rgba.g - p2_rgba.g);
        result_b += abs(p1_rgba.b - p2_rgba.b);

        // Sum all responses before thresholding
        float total_response = abs(result_r + result_g + result_b);

        // Finally store the final response for this angle
        if(i == 0) {
          angle_responses[0] = applyThreshold(total_response, 0.5);
        } else if(i == 1) {
          angle_responses[1] = applyThreshold(total_response, 0.5);
        } else if(i == 2) {
          angle_responses[2] = applyThreshold(total_response, 0.5);
        } else if(i == 3) {
          angle_responses[3] = applyThreshold(total_response, 0.5);
        }
      }

      gl_FragColor = angle_responses;
    }
  </script>

  <!-- Reduction shader -->
  <script id="row-reduction-shader-fs" type="x-shader/x-fragment">
    // Reduces a WxH texture data to a single Wx1 row (4 channels each pixel)
    precision mediump float;
    
    uniform sampler2D input_texture;
    uniform vec2 input_texture_size;

    varying vec4 pass_Color; // Unused/for debugging purposes
    varying vec2 pass_TextureCoord;
    
    void main(void) {
      vec4 angles_result = vec4(0.0, 0.0, 0.0, 0.0);

      float increment = 1.0 / input_texture_size.y;
      
      // Notice that center of texel is at 0.5
      float real_index = 0.0;
      for(float i = 0.0; i < 1024.0; i += 0.0) { // Another workaround for constant expressions
        if(real_index >= input_texture_size.y)
          break;
        real_index += increment; // Real increment due to workaround
        
        angles_result += texture2D(input_texture, vec2(pass_TextureCoord.x, real_index));
      }
      gl_FragColor.x = angles_result.x / 512.0;
      gl_FragColor.y = angles_result.y / 512.0;
      gl_FragColor.z = angles_result.z / 512.0;
      gl_FragColor.w = angles_result.w / 512.0;
    }
    
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance
    
    function webGLStart() {
      var canvas = document.getElementById("filter-canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }
   
      setupQuad();
      initFramebuffer();
      initShaderPrograms();
      initTextures();
      
      ctx = WebGLDebugUtils.makeDebugContext(gl.clearColor(0.0, 0.0, 0.0, 1.0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enable(gl.DEPTH_TEST));
      
      paintLoop();
    }
    
    // Geometric and quad rendering data
    var vboId;  // Quad data
    var vboiId; // Quad indices
    var indices_count;
    var mvMatrix = mat4.create(); // Warning: does not default to identity
    var pMatrix = mat4.create();  // Warning: does not default to identity

    // Input texture
    var textureId;
    var imageDimensions = [0.0, 0.0];
    var textureIsSafeToRender = false; // Indicates whether the texture has been loaded

    // Distortion correction factors
    var alphax = 0.0;
    var alphay = 0.0;
    var maximum_alpha = 0.25;

    // Shader programs
    var undistortionShaderProgram; // Applies the undistortion filtering
    var histogramComputerShaderProgram; // Calculates the edge histogram
    var histogramReductionShaderProgram; // Reduces an histogram texture to a single row
    var debugProgram; // Just visualizes a texture

    // Secondary framebuffers for intermediate computations and textures
    var renderFrameBuffer;
    var undistortionTexture;
    var histogram_responses_0;
    var histogram_responses_1;
    var histogram_responses_2;
    var histogram_reduced_row;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        ctx = WebGLDebugUtils.makeDebugContext(shader = gl.createShader(gl.FRAGMENT_SHADER));
      } else if (shaderScript.type == "x-shader/x-vertex") {
        ctx = WebGLDebugUtils.makeDebugContext(shader = gl.createShader(gl.VERTEX_SHADER));
      } else {
        return null;
      }

      ctx = WebGLDebugUtils.makeDebugContext(gl.shaderSource(shader, str));
      ctx = WebGLDebugUtils.makeDebugContext(gl.compileShader(shader));

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    // Init the undistortion framebuffer and its texture
    function initFramebuffer() {
      ctx = WebGLDebugUtils.makeDebugContext(renderFrameBuffer = gl.createFramebuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer));
      renderFrameBuffer.width = 512;
      renderFrameBuffer.height = 512;

      var renderbuffer;
      ctx = WebGLDebugUtils.makeDebugContext(renderbuffer = gl.createRenderbuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderFrameBuffer.width, renderFrameBuffer.height));
      renderFrameBuffer.renderBuffer = renderbuffer; // Save it for later use

      ctx = WebGLDebugUtils.makeDebugContext(gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer));
      
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    }

    function attachTextureToFrameBuffer(texture) {
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    }

    function initShaderPrograms() {
      // ~-~-~-~-~-~-~- Init the undistortion shader program ~-~-~-~-~-~-~-
      var fragmentShader = getShader(gl, "undistortion-shader-fs");
      var vertexShader = getShader(gl, "neuter-shader-vs");

      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram = gl.createProgram());
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(undistortionShaderProgram, vertexShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(undistortionShaderProgram, fragmentShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.linkProgram(undistortionShaderProgram));

      if (!gl.getProgramParameter(undistortionShaderProgram, gl.LINK_STATUS)) {
          alert("Could not initialize shaders");
      }

      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(undistortionShaderProgram));

      // Enable vertex attribute arrays for position, color, uvs
      
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.inPosition = gl.getAttribLocation(undistortionShaderProgram, "in_Position"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(undistortionShaderProgram.inPosition));

      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.inColor = gl.getAttribLocation(undistortionShaderProgram, "in_Color"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(undistortionShaderProgram.inColor));
      
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.inTextureCoord = gl.getAttribLocation(undistortionShaderProgram, "in_TextureCoord"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(undistortionShaderProgram.inTextureCoord));
      
      // Bind uniforms for matrices
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.pMatrixUniform = gl.getUniformLocation(undistortionShaderProgram, "uPMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.mvMatrixUniform = gl.getUniformLocation(undistortionShaderProgram, "uMVMatrix"));
      
      // Bind uniform for image dimensions and alpha factors
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.imageDimensionsUniform = gl.getUniformLocation(undistortionShaderProgram, "image_dimensions"));
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.alphax = gl.getUniformLocation(undistortionShaderProgram, "alphax"));
      ctx = WebGLDebugUtils.makeDebugContext(undistortionShaderProgram.alphay = gl.getUniformLocation(undistortionShaderProgram, "alphay"));
      
      // ~-~-~-~-~-~-~- Init the histogram computer shader program ~-~-~-~-~-~-~-
      
      var edgeFragmentShader = getShader(gl, "histogram-computer-shader-fs");
      var edgeVertexShader = getShader(gl, "neuter-shader-vs");
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram = gl.createProgram());
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(histogramComputerShaderProgram, edgeVertexShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(histogramComputerShaderProgram, edgeFragmentShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.linkProgram(histogramComputerShaderProgram));
      if (!gl.getProgramParameter(histogramComputerShaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(histogramComputerShaderProgram));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.inPosition = gl.getAttribLocation(histogramComputerShaderProgram, "in_Position"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramComputerShaderProgram.inPosition));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.inColor = gl.getAttribLocation(histogramComputerShaderProgram, "in_Color"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramComputerShaderProgram.inColor));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.inTextureCoord = gl.getAttribLocation(histogramComputerShaderProgram, "in_TextureCoord"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramComputerShaderProgram.inTextureCoord));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.pMatrixUniform = gl.getUniformLocation(histogramComputerShaderProgram, "uPMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.mvMatrixUniform = gl.getUniformLocation(histogramComputerShaderProgram, "uMVMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.texture_size = gl.getUniformLocation(histogramComputerShaderProgram, "input_texture_size"));
      ctx = WebGLDebugUtils.makeDebugContext(histogramComputerShaderProgram.rotation_du = gl.getUniformLocation(histogramComputerShaderProgram, "rotation_du"));      

      // ~-~-~-~-~-~-~- Init the histogram reduction shader program ~-~-~-~-~-~-~-

      var rowReductionFragmentShader = getShader(gl, "row-reduction-shader-fs");
      var rowReductionVertexShader = getShader(gl, "neuter-shader-vs");
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram = gl.createProgram());
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(histogramReductionShaderProgram, rowReductionVertexShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(histogramReductionShaderProgram, rowReductionFragmentShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.linkProgram(histogramReductionShaderProgram));
      if (!gl.getProgramParameter(histogramReductionShaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(histogramReductionShaderProgram));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.inPosition = gl.getAttribLocation(histogramReductionShaderProgram, "in_Position"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramReductionShaderProgram.inPosition));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.inColor = gl.getAttribLocation(histogramReductionShaderProgram, "in_Color"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramReductionShaderProgram.inColor));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.inTextureCoord = gl.getAttribLocation(histogramReductionShaderProgram, "in_TextureCoord"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(histogramReductionShaderProgram.inTextureCoord));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.pMatrixUniform = gl.getUniformLocation(histogramReductionShaderProgram, "uPMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.mvMatrixUniform = gl.getUniformLocation(histogramReductionShaderProgram, "uMVMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(histogramReductionShaderProgram.texture_size = gl.getUniformLocation(histogramReductionShaderProgram, "input_texture_size"));

      // ~-~-~-~-~-~-~- Init the debug shader program ~-~-~-~-~-~-~-

      var debugFragmentShader = getShader(gl, "debug-fs");
      var debugVertexShader = getShader(gl, "debug-vs");
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram = gl.createProgram());
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(debugProgram, debugVertexShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.attachShader(debugProgram, debugFragmentShader));
      ctx = WebGLDebugUtils.makeDebugContext(gl.linkProgram(debugProgram));
      if (!gl.getProgramParameter(debugProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
      }
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(debugProgram));
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram.inPosition = gl.getAttribLocation(debugProgram, "in_Position"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(debugProgram.inPosition));
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram.inColor = gl.getAttribLocation(debugProgram, "in_Color"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(debugProgram.inColor));
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram.inTextureCoord = gl.getAttribLocation(debugProgram, "in_TextureCoord"));
      ctx = WebGLDebugUtils.makeDebugContext(gl.enableVertexAttribArray(debugProgram.inTextureCoord));
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram.pMatrixUniform = gl.getUniformLocation(debugProgram, "uPMatrix"));
      ctx = WebGLDebugUtils.makeDebugContext(debugProgram.mvMatrixUniform = gl.getUniformLocation(debugProgram, "uMVMatrix"));
    }
    
    function setupQuad() {
      // Set up VBO with quad data
      ctx = WebGLDebugUtils.makeDebugContext(vboId = gl.createBuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, vboId));
      var vbo_data = [
        -1.0, 1.0, -1.0, 1.0,   // Vertex (xyzw)
        1.0, 0.0, 0.0, 1.0,     // RGBA
        0.0, 1.0,               // UV coords
        
        -1.0, -1.0, -1.0, 1.0,  // Vertex (xyzw)
        0.0, 1.0, 0.0, 1.0,     // RGBA
        0.0, 0.0,               // UV coords
        
        1.0, -1.0, -1.0, 1.0,   // Vertex (xyzw)
        0.0, 0.0, 1.0, 1.0,     // RGBA
        1.0, 0.0,               // UV coords
        
        1.0, 1.0, -1.0, 1.0,    // Vertex (xyzw)
        1.0, 1.0, 1.0, 1.0,     // RGBA
        1.0, 1.0                // UV coords
      ];
      ctx = WebGLDebugUtils.makeDebugContext(gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW));
      // Set up VBO with indices data
      ctx = WebGLDebugUtils.makeDebugContext(vboiId = gl.createBuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId));
      var indices = [
        0, 1, 2,
        2, 3, 0
      ];
      ctx = WebGLDebugUtils.makeDebugContext(gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW));
      indices_count = indices.length;      
    }    

    function initTextures() {
      // ~-~-~-~-~-~- Input texture ~-~-~-~-~-~-
      ctx = WebGLDebugUtils.makeDebugContext(textureId = gl.createTexture());
      textureId.image = new Image();
      textureId.image.onload = function () {
        ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, textureId));
        ctx = WebGLDebugUtils.makeDebugContext(gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true));        
        ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureId.image));
        ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR));
        ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR));
        ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));
        textureIsSafeToRender = true;
      }      
      textureId.image.src = "assets/testdata.png";
      imageDimensions = new Float32Array([textureId.image.width, textureId.image.height]);

      // ~-~-~-~-~-~- Undistorted texture ~-~-~-~-~-~-
      ctx = WebGLDebugUtils.makeDebugContext(undistortionTexture = gl.createTexture());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, undistortionTexture));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderFrameBuffer.width,
                                             renderFrameBuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));

      // ~-~-~-~-~-~- Histogram computing textures ~-~-~-~-~-~-
      ctx = WebGLDebugUtils.makeDebugContext(histogram_responses_0 = gl.createTexture());
      ctx = WebGLDebugUtils.makeDebugContext(histogram_responses_1 = gl.createTexture());
      ctx = WebGLDebugUtils.makeDebugContext(histogram_responses_2 = gl.createTexture());
      
      var setTextureSize = function () {
        ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR));
        ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR));
        ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderFrameBuffer.width,
                                               renderFrameBuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      }

      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, histogram_responses_0));
      setTextureSize();
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, histogram_responses_1));
      setTextureSize();
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, histogram_responses_2));
      setTextureSize();

      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));

      // ~-~-~-~-~-~- Reduction textures ~-~-~-~-~-~-
      ctx = WebGLDebugUtils.makeDebugContext(histogram_reduced_row = gl.createTexture());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, histogram_reduced_row));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR));
      // width x 1 output (one row)
      ctx = WebGLDebugUtils.makeDebugContext(gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, renderFrameBuffer.width,
                                             1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));
    }

    // Render an undistorted image in the framebuffer texture
    function renderUndistortedInFramebuffer() {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Makes sure we're rendering the entire texture (this will LATER be mapped to the viewport)
      ctx = WebGLDebugUtils.makeDebugContext(gl.viewport(0, 0, 512, 512));
      ctx = WebGLDebugUtils.makeDebugContext(gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT));     

      // Set up undistortion shader program
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(undistortionShaderProgram));

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(undistortionShaderProgram.pMatrixUniform, false, pMatrix));
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(undistortionShaderProgram.mvMatrixUniform, false, mvMatrix));

      // ------------ Filtering-specific data ------------
      // Set image dimensions uniform
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform2fv(undistortionShaderProgram.imageDimensionsUniform, imageDimensions));

      // Set alpha factors uniforms
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1fv(undistortionShaderProgram.alphax, new Float32Array([alphax])));
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1fv(undistortionShaderProgram.alphay, new Float32Array([alphay])));
      // --------------------------------------------------

      // Bind texture to texture unit 0
      ctx = WebGLDebugUtils.makeDebugContext(gl.activeTexture(gl.TEXTURE0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, textureId));
      var sampler2D_loc = gl.getUniformLocation(undistortionShaderProgram, "texture_diffuse");
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1i(sampler2D_loc, 0));

      // Bind vertex data and set vertex attributes (as from a VAO)
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, vboId));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(undistortionShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(undistortionShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(undistortionShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4));

      // Bind vertex index info
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId));

      // Draw the quad
      ctx = WebGLDebugUtils.makeDebugContext(gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0));

      // Cleanup
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Calculates histogram data. 'response_part' is the histogram part that
    // has to be calculated (see the fragment shader for more info)
    function calculateHistogramDataInFramebuffer(response_part) {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Makes sure we're rendering the entire texture
      ctx = WebGLDebugUtils.makeDebugContext(gl.viewport(0, 0, 512, 512));
      ctx = WebGLDebugUtils.makeDebugContext(gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT));

      // Set up histogram calculator shader program
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(histogramComputerShaderProgram));

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(histogramComputerShaderProgram.pMatrixUniform, false, pMatrix));
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(histogramComputerShaderProgram.mvMatrixUniform, false, mvMatrix));

      // Set texture size uniforms
      var texture_size = [512.0, 512.0];
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform2fv(histogramComputerShaderProgram.texture_size, texture_size));

      // Set the response part to be calculated
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1i(histogramComputerShaderProgram.response_part, response_part));

      // Bind texture to texture unit 0
      ctx = WebGLDebugUtils.makeDebugContext(gl.activeTexture(gl.TEXTURE0));
      //ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, undistortionTexture));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, textureId)); // DEBUG DEBUG DEBUG
      var sampler2D_loc = gl.getUniformLocation(histogramComputerShaderProgram, "input_texture");
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1i(sampler2D_loc, 0));

      // Fill the angle increments for the histogram computer shader      
      var vectors = new Float32Array(4 * 2); // 4 vec2 increments, (see fragment shader)
      var angle_increment_degrees = 15.0;
      for (i = response_part * 4; i < response_part * 4 + 4; i++) {
        var angle_radians = (i * angle_increment_degrees) / 180.0 * Math.PI;

        vectors[(i - response_part * 4) * 2] = Math.cos(angle_radians) / 512.0;
        vectors[(i - response_part * 4) * 2 + 1] = Math.sin(angle_radians) / 512.0;
      }
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform2fv(histogramComputerShaderProgram.rotation_du, vectors));

      // Bind vertex data and set vertex attributes (as from a VAO)
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, vboId));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramComputerShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramComputerShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramComputerShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4));

      // Bind vertex index info
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId));

      // Draw the quad
      ctx = WebGLDebugUtils.makeDebugContext(gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0));

      // Cleanup
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Computes a reduction to one row for the histogram data. 'histogram_part' is
    // the texture data (i.e. the texture containing part of the histogram).
    // 'starting_angle' is the starting angle index in the hemisphere of rotation
    // vectors
    function histogramReductionInFramebuffer(histogram_part) {
      // Bind secondary framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderFrameBuffer);

      // Resize secondary framebuffer depth buffer to accommodate for the Wx1 output texture
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, renderFrameBuffer.renderBuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderFrameBuffer.width, 1));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, null));

      // Sets only one row of pixels to be computed
      ctx = WebGLDebugUtils.makeDebugContext(gl.viewport(0, 0, 512, 1));
      ctx = WebGLDebugUtils.makeDebugContext(gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT));

      // Set up histogram reduction shader program
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(histogramReductionShaderProgram));

      // Set up projection and movelview uniforms
      // Map the texture perfectly to the viewport (i.e. project the quad to the front)
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(histogramReductionShaderProgram.pMatrixUniform, false, pMatrix));
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(histogramReductionShaderProgram.mvMatrixUniform, false, mvMatrix));

      // Set texture size uniforms
      var texture_size = [512.0, 512.0];
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform2fv(histogramReductionShaderProgram.texture_size, texture_size));

      // Bind the right texture input to texture unit 0
      ctx = WebGLDebugUtils.makeDebugContext(gl.activeTexture(gl.TEXTURE0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, histogram_part));
      // Since these are data textures, in order to facilitate lookup set nearest filters
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
      ctx = WebGLDebugUtils.makeDebugContext(gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
      var sampler2D_loc = gl.getUniformLocation(histogramReductionShaderProgram, "input_texture");
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1i(sampler2D_loc, 0));      

      // Bind vertex data and set vertex attributes (as from a VAO)
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, vboId));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramReductionShaderProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramReductionShaderProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(histogramReductionShaderProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4));

      // Bind vertex index info
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId));

      // Draw the quad
      ctx = WebGLDebugUtils.makeDebugContext(gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0));

      // Cleanup
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));

      // Restore normal framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      // Also restore normal depth buffer
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, renderFrameBuffer.renderBuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderFrameBuffer.width, renderFrameBuffer.height));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, null));
    }
  
    // Given a reduced texture row (histogram data) reduces this on the CPU to a
    // simple array of 4 angles
    function getComponentsFromReducedTexture(texture) {
      // Create a framebuffer backed by the supplied texture
      var framebuffer;
      ctx = WebGLDebugUtils.makeDebugContext(framebuffer = gl.createFramebuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));

      var renderbuffer;
      ctx = WebGLDebugUtils.makeDebugContext(renderbuffer = gl.createRenderbuffer());
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 512, 1));
      framebuffer.renderBuffer = renderbuffer;
      ctx = WebGLDebugUtils.makeDebugContext(gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindRenderbuffer(gl.RENDERBUFFER, null));

      ctx = WebGLDebugUtils.makeDebugContext(gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
      // Read the contents of the texture from the framebuffer
      var data_uint8 = new Uint8Array(512 * 1 * 4); // 512 x 1 normalized floats times 4 angles
      ctx = WebGLDebugUtils.makeDebugContext(gl.readPixels(0, 0, 512, 1, gl.RGBA, gl.UNSIGNED_BYTE, data_uint8));
      var result_angles = new Float32Array(4);
      result_angles[0] = 0.0;
      result_angles[1] = 0.0;
      result_angles[2] = 0.0;
      result_angles[3] = 0.0;
      // Reduce data
      for (i = 0; i < 512; ++i) {
        result_angles[0] += (data_uint8[i * 4]) / 255.0;
        result_angles[1] += (data_uint8[i * 4 + 1]) / 255.0;
        result_angles[2] += (data_uint8[i * 4 + 2]) / 255.0;
        result_angles[3] += (data_uint8[i * 4 + 3]) / 255.0;
      }
      result_angles[0] /= 512.0;
      result_angles[1] /= 512.0;
      result_angles[2] /= 512.0;
      result_angles[3] /= 512.0;
      ctx = WebGLDebugUtils.makeDebugContext(gl.deleteFramebuffer(framebuffer));
      return result_angles;
    }

    function drawScene() {
      
      if(textureIsSafeToRender == false)
        return; // Still can't render stuff if the texture hasn't been loaded yet

      // First render an undistorted image in the framebuffer texture
      attachTextureToFrameBuffer(undistortionTexture);
      renderUndistortedInFramebuffer();

      // Render and calculate all the histogram responses
      attachTextureToFrameBuffer(histogram_responses_0);
      calculateHistogramDataInFramebuffer(0);

      // DEBUG
      outputVisualFeedback = function (texture) {
        // Create a framebuffer backed by the texture
        var framebuffer;
        ctx = WebGLDebugUtils.makeDebugContext(framebuffer = gl.createFramebuffer());
        ctx = WebGLDebugUtils.makeDebugContext(gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
        ctx = WebGLDebugUtils.makeDebugContext(gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
        var width = 512.0;
        var height = 512.0;
        // Read the contents of the framebuffer
        var data = new Uint8Array(width * height * 4);
        var data_flipped = new Uint8Array(width * height * 4);

        ctx = WebGLDebugUtils.makeDebugContext(gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data));
        // Flip webgl data (usually Y-inverse stored)
        for (y = 0; y < height; ++y) {
          for (x = 0; x < width; ++x) {
            data_flipped[y * width * 4 + x * 4]     = data[(height - 1 - y) * width * 4 + x * 4];            
            data_flipped[y * width * 4 + x * 4 + 1] = 0;
            data_flipped[y * width * 4 + x * 4 + 2] = 0;
            data_flipped[y * width * 4 + x * 4 + 3] = 255;
          }
        }

        ctx = WebGLDebugUtils.makeDebugContext(gl.deleteFramebuffer(framebuffer));

        // Create a 2D canvas to store the result 
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');

        // Copy the pixels to a 2D canvas
        var imageData = context.createImageData(width, height);
        imageData.data.set(data_flipped);
        context.putImageData(imageData, 0, 0);

        return canvas.toDataURL();
      }
      var img = document.getElementById("debug-img");
      img.src = outputVisualFeedback(histogram_responses_0);

      return;

      attachTextureToFrameBuffer(histogram_responses_1);
      calculateHistogramDataInFramebuffer(1);
      attachTextureToFrameBuffer(histogram_responses_2);
      calculateHistogramDataInFramebuffer(2);

      // Now reduce all the responses
      attachTextureToFrameBuffer(histogram_reduced_row); // Output into this

      histogramReductionInFramebuffer(histogram_responses_0);
      var histogram_part0 = getComponentsFromReducedTexture(histogram_reduced_row);

      histogramReductionInFramebuffer(histogram_responses_1);
      var histogram_part1 = getComponentsFromReducedTexture(histogram_reduced_row);

      histogramReductionInFramebuffer(histogram_responses_2);
      var histogram_part2 = getComponentsFromReducedTexture(histogram_reduced_row);

      console.log("Reduction done\n");


      // Debug
      //var img = document.getElementById("debug-img");
      //img.src = createImageFromTexture(gl, edgeDetectionTexture, 512, 512);
      
      // Debug - re-render back
      
      // This time only draw the canvas size
      ctx = WebGLDebugUtils.makeDebugContext(gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight));
      ctx = WebGLDebugUtils.makeDebugContext(gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT));
      //mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
      mat4.identity(pMatrix);
      mat4.identity(mvMatrix);
      //mat4.translate(mvMatrix, [0.0, 0.0, -1.2]);
      ctx = WebGLDebugUtils.makeDebugContext(gl.useProgram(debugProgram)); // Set up debug program
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(debugProgram.pMatrixUniform, false, pMatrix));
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniformMatrix4fv(debugProgram.mvMatrixUniform, false, mvMatrix));
      ctx = WebGLDebugUtils.makeDebugContext(gl.activeTexture(gl.TEXTURE0));      

      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, undistortionTexture));
      var sampler2D_loc = gl.getUniformLocation(debugProgram, "texture_diffuse");
      ctx = WebGLDebugUtils.makeDebugContext(gl.uniform1i(sampler2D_loc, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, vboId));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(debugProgram.inPosition, 4, gl.FLOAT, false, 10 * 4 /* 10 floats */, 0));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(debugProgram.inColor, 4, gl.FLOAT, false, 10 * 4, 4 * 4));
      ctx = WebGLDebugUtils.makeDebugContext(gl.vertexAttribPointer(debugProgram.inTextureCoord, 2, gl.FLOAT, false, 10 * 4, 8 * 4));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboiId));

      ctx = WebGLDebugUtils.makeDebugContext(gl.drawElements(gl.TRIANGLES, indices_count, gl.UNSIGNED_SHORT, 0));

      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindBuffer(gl.ARRAY_BUFFER, null));
      ctx = WebGLDebugUtils.makeDebugContext(gl.bindTexture(gl.TEXTURE_2D, null));
    }
    
    function paintLoop() {    
      requestAnimFrame(paintLoop);
      drawScene();      
    }
    
    // ~-~-~-~-~-~-~-~-~- UI related handling routines ~-~-~-~-~-~-~-~-~-
    
    var same_alpha_factors = true; // Whether alphax and alphay are forced to be equal
    
    function adjustAlphaFactor(direction, value) { // value should be in range [0;100]
      switch(direction) {
        case 'x': {
          alphax = (value * 0.01) * maximum_alpha;
          document.getElementById("alphax_value").value = alphax;
          if(same_alpha_factors) {
            alphay = alphax;
            document.getElementById("alphay_slider").value = value;
            document.getElementById("alphay_value").value = alphay;
          }
        } break;
        case 'y': {
          alphay = (value * 0.01) * maximum_alpha;
          document.getElementById("alphay_value").value = alphay;
          if(same_alpha_factors) {
            alphax = alphay;
            document.getElementById("alphax_slider").value = value;
            document.getElementById("alphax_value").value = alphax;
          }
        } break;
      }
    }
    // ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
        
  </script>
</head>
<body onload="webGLStart();">
  <div style="padding: 10px;">
    <div style="float: left;">
      <!-- WARNING: KEEP THE DIMENSIONS UNDER 512x512, OTHERWISE A BIGGER TEXTURE IS NEEDED -->
      <canvas id="filter-canvas" style="border: none;" width="500" height="500"></canvas>
    </div>
    <div style="float: left; padding: 10px;">
      <input type="checkbox" onchange="same_alpha_factors = this.checked;" checked/>Force square pixels<br/><br/>
      Adjust horizontal distortion parameter<br/>
      <input id="alphax_slider" type="range" style="vertical-align:middle;" min="0" max="100" value="0" onchange="adjustAlphaFactor('x', this.value)"
       oninput="adjustAlphaFactor('x', this.value)"/>
      <input type="text" id="alphax_value" style="vertical-align:middle; width: 50px; text-align: center;" value="0.0" readonly><br/>
      Adjust vertical distortion parameter<br/>
      <input id="alphay_slider" type="range" style="vertical-align:middle;" min="0" max="100" value="0" onchange="adjustAlphaFactor('y', this.value)"
      oninput="adjustAlphaFactor('y', this.value)"/>
      <input type="text" id="alphay_value" style="vertical-align:middle; width: 50px; text-align: center;" value="0.0" readonly><br/>
      <div style="float: left; padding: 20px">
          <img style="vertical-align:middle;" src="http://marcodiiga.github.io/images/webicon-github-m.png"/>
          <a href="https://github.com/marcodiiga/lens_distortion_filtering">Github Repo</a>
      </div>
    </div>
  </div>
  <br />
  <img id="debug-img" />
  <a id="debug-anchor" href="">Download first texture histogram as text file</a>
</body>
</html>


